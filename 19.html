<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8"></meta>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Блог Стебунова Владимира</title>
		<link rel="stylesheet" type="text/css" href="main.css">	
        <meta property="og:title" content="Простые примеры програм на TLA+ и +Cal" />
		
	</head>
	<body>
		<header>
            <h1><a href="/" class="h-card">Блог Стебунова Владимира</a></h1>
		</header>
		<main>
			<article>
				<time datetime=08-06-2022>18 июня 2022</time>
				<h1 id="простые-примеры-програм-на-tla-и-cal">Простые примеры програм на TLA+ и +Cal</h1>
<p>Данные язык и его расширение инструменты для верификации программ. Под капотом там находится машина генерирующая граф и полученной модели программы. С какой-то стороны код здесь становиться частью данных. Важной частью является модель и её свойства которые задаются отдельно. Свойства модели могут описываться более богатым языком, чем сама программа.</p>
<p>Так как самое главное это понять окно <strong>Model Overview</strong> и <strong>Model Checking result</strong>.</p>
<h2 id="вывод-графа">Вывод графа</h2>
<p>На маленьких моделях можно видеть весь граф исполнения, и это очень полезно на начальных этапах понимания языка. Для включения вывода графа необходимо в <strong>Model Overview</strong> нажать на кнопку <strong>Additional TLC Options</strong> и выбрать <strong>Features</strong>, а там <strong>Visualize state after graph compilation</strong>.</p>
<h2 id="минимальная-программа">Минимальная программа</h2>
<p>Как мне сейчас кажется минимальной программой-моделью показывающей хотя бы начало может быть что-то такое:</p>
<pre><code>(*--algorithm noproblem
variables
    x = 0;
begin
    START:
        x := 1;
end algorithm;**)</code></pre>
<p>Программа просто присваевает <em>x</em> значение 1 и заканчивается. После того как произойдет трансляция из +Cal В TLA+ можно запустить программу и увидеть что она верифицируется.Но это не очень интересно. Для нас интерес представляет когда модель показывает несостоятельность нашей программы. Для начала проверим что наша модель проверяется на Deadlock. Для этого в What to check? проверим что галочка Deadlock проставлена. Изменим код на вот такой:</p>
<pre><code>EXTENDS TLC, Sequences, Integers, FiniteSets

(*--algorithm noproblem
variables
    x \in 0..3
begin    
    START:
        await x = 1;
    ATOMIC_OPERATION:
        x := 1;
end algorithm;**)</code></pre>
<p>Команда <em>await</em> ожидает условия, так как наше условие не выполняется никогда, мы получаем ошибку о том что Deadlock достигнут. Самой важной панелькой теперь становиться <strong>Error Trace</strong> он показывает как мы достигли ошибочного состояния. В данном случае тупика. У нас это произошло очень легко, чекер выбрал для <em>x</em> не то состояние (0,2,3) и программа пришла в тупик.</p>
<h2 id="свойства-и-инварианты">Свойства и инварианты</h2>
<p>Слепое доверие что модель работает, не очень интересно и для этого нужны инварианты и свойства. При нарушении их модель покажет, как мы попали в это состояние.</p>
<p>Изменим нашу модель таким образом:</p>
<pre><code>(*--algorithm noproblem
variables
    x = 1;
begin    
    START:
        await x = 1;
    ATOMIC_OPERATION:
        x := 1;
end algorithm;**)

\* BEGIN TRANSLATION 
..
\* END TRANSLATION 

XAlwaysOne == [](x = 1)</code></pre>
<h3 id="свойства">Свойства</h3>
<p><em>XAlwaysOne</em> это свойство, что <em>x = 1</em>. Добавляем его в <strong>What to check  Propertes</strong> и видим что оно выполняется всегда.</p>
<p>Но мы можем поменять нашу атомную операцию сделать <em>x := 2</em> и увидеть, что это свойство не выполняется когда мы исполняем атомную операцию.</p>
<p>Свойства проверяют именно поведение.</p>
<h3 id="инвариант">Инвариант</h3>
<p>Добавим бросок кубика и сложение к одному</p>
<pre><code>(*--algorithm noproblem
variables
    x = 1,
    dice \in 1..6;
begin    
    START:
        await x = 1;
    ATOMIC_OPERATION:
        x := 1;
    INT_OPERATION:
        dice := dice + 1;
end algorithm;**)</code></pre>
<p>Количество состояний нашей модели увеличилось.</p>
<p>Если свойство проверяют пути то, инварианты должны быть правильными в каждом доступном состоянии, добавим проверку, что кубик у нас всегда шестигранный.</p>
<pre><code>DiceRightVariant == dice &gt; 0 /\ dice &lt; 7</code></pre>
<p>И допишем его в модель <strong>What to check  Invariants</strong>.</p>
<p>После запуска видно, что такой вариант достижим если выпало 6 на кубике.</p>
<p>Инварианты лучше проверять как параметры, которые не допустимы для системы всегда.</p>
<h3 id="свойства-1">Свойства</h3>
<p>Изменим нашу модель таким образом:</p>
<pre><code>(*--algorithm noproblem
variables
    x = 1,
    dice \in 1..6;
begin    
    START:
        await x = 1;
    ATOMIC_OPERATION:
        x := 1;
    INT_OPERATION:
        dice := dice + 1;
        if (dice &gt; 3) then
            x := x + dice
        end if
end algorithm;**)</code></pre>
<p>Если на кубике больше трёх, то прибавляем его к <em>x</em>, сделаем свойство которое проверяет что никогда наш <em>x</em> не может стать цифрой 8.</p>
<pre><code>XProp == ~&lt;&gt;(x = 8)</code></pre>
<p>После рекомпиляции и запуска видим, что если на кубике выпало 6, то наше свойство не выполнится если на кубике выпало 6.</p>
<h3 id="основной-цикл-верификации">Основной цикл верификации</h3>
<p>Следует рассматривать этот язык как диалог с машиной, позволяющий уточнить понимание модели и её свойств. Потому что на каждом шаге при появлении ошибки, следует ввести, свойство или изменить алгоритм.</p>
			</article>
			<p>
                <a href="20.html">Следующая статья</a>
			</p>
			<p>
                <a href="18.html">Предыдущая статья</a>
			</p>
		</main>
		<hr/>
		<footer>
			<p>Любая перепечатка материалов возможна только с разрешения владельца сайта</p>
		</footer>
	</body>
</html>
